# This script creates the server code for the Shiny application.

library(shiny)
library(dplyr)
library(plotly)
library(leaflet)
library(sf)
library(countrycode)
options(geonamesUsername="codrin")
library(geonames)


# Define server logic required to draw a histogram
shinyServer(function(input, output) {
  
  # Read in data generated by liveso.R
  df_merged <- readRDS("data/liveso_data.rds")
  world_sp <- as(df_merged, "Spatial")
  
  # Create base map
  base_map <- world_sp %>%
                leaflet() %>%
                # addProviderTiles("Stamen.Watercolor", group = "Historical") %>%
                # addProviderTiles("Esri.WorldPhysical", group = "Physical") %>%
                # addProviderTiles("Esri.NatGeoWorldMap", group = "NatGeo") %>% 
                addProviderTiles("OpenStreetMap.HOT", group = "Humanitarian") # %>% # https://www.hotosm.org
                # addLayersControl(baseGroups = c("Historical", "Physical", "NatGeo", "Humanitarian"))
  
  # World map with country polygons
  output$leaflet_world <- renderLeaflet({
    base_map %>%
      addPolygons(weight = 1, color = ~hpi_2016,
                  label = ~hover,
                  highlight = highlightOptions(weight = 5, color = "white",
                                               bringToFront = TRUE))
  })
  
  # Country specific data
  
  countrySelected <- eventReactive(input$leaflet_world_click, {
      # Get the click info like had been doing
      click <- input$leaflet_world_click
      clat <- click$lat
      clng <- click$lng
      
      # Lookup country
      countrycode(GNcountryCode(lat = clat, lng = clng)$countryCode, "iso2c", "iso3c")
  })
  
  # Index plot
  output$index_plot <- renderPlot({
    country_gdp <- round(world_sp[world_sp$country_code == countrySelected()[[1]],]$gdp_scaled[1], 2)
    gdp_center <- attributes(world_sp$gdp_scaled)$`scaled:center`
    gdp_scale <- attributes(world_sp$gdp_scaled)$`scaled:scale`
    
    country_spi <- round(world_sp[world_sp$country_code == countrySelected()[[1]],]$spi_scaled[1], 2)
    spi_center <- attributes(world_sp$spi_scaled)$`scaled:center`
    spi_scale <- attributes(world_sp$spi_scaled)$`scaled:scale`
    
    country_fp <- round(world_sp[world_sp$country_code == countrySelected()[[1]],]$fp_scaled[1], 2)
    fp_center <- attributes(world_sp$fp_scaled)$`scaled:center`
    fp_scale <- attributes(world_sp$fp_scaled)$`scaled:scale`
    
    country_hpi <- round(world_sp[world_sp$country_code == countrySelected()[[1]],]$hpi_scaled[1], 2)
    hpi_center <- attributes(world_sp$hpi_scaled)$`scaled:center`
    hpi_scale <- attributes(world_sp$hpi_scaled)$`scaled:scale`
    
    plot_data <- data_frame("description" = c("Country GDP",
                                              "Country SPI",
                                              "Country FP",
                                              "Country HPI"),
                            "value" = c(country_gdp,
                                        country_spi,
                                        country_fp,
                                        country_hpi))
    
    ggplot(plot_data, aes(x = as.factor(description), y = value)) + geom_col()
  })
  
  ### GDP TAB
  
  # GDP map
  output$gdp_map <- renderPlotly({
    
    # light grey boundaries
    l <- list(color = toRGB("grey"), width = 0.5)
    
    # specify map projection/options
    g <- list(
      showframe = FALSE,
      showcoastlines = FALSE,
      projection = list(type = "winkel triple")
    )
    
    p <- plot_geo(data = df_merged[c("country",
                                    "country_code",
                                    "hover",
                                    "gdp_2016")],
                  z = ~gdp_2016,
                  color = ~gdp_2016,
                  text = ~hover,
                  locations = ~country_code,
                  type = 'choropleth') %>%
          layout(geo = g)
    p
  })
  
})
